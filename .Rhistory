ceiling(234.353)
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
now
Sys.time()
as.numeric(sys.time())
as.numeric(Sys.time())
as.numeric(Sys.time())
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
install.packages("extrafont")
library(extrafont)
fonts()
font()
fonts()
font_import()
fonts()
ggplot()+theme_minimal()+geom_text("Hello")
ggplot()+theme_minimal()+geom_point()
ggplot()+theme_minimal()+geom_point()+ggtitle("No Data Available")
ggplot()+theme_minimal()+geom_point()+ggtitle("No Data Available",family="TeleGrotesk Headline Ultra")
ggplot()+theme_minimal()+geom_point()+ggtitle("No Data Available")+theme(family="TeleGrotesk Headline Ultra")
df <- data.frame(x=[0,1],y=[0,1])
df <- data.frame(x=c(0,1),y=c(0,1))
df
ggplot(df,aes(x=x,y=y))+geom_point()+theme_minimal()
df <- data.frame(x=c(),y=c())
ggplot(df,aes(x=x,y=y))+geom_point()+theme_minimal()
df
df <- data.frame(x=c(0,1),y=c(0,1))
ggplot(df,aes(x=x,y=y))+geom_point()+theme_minimal()+geom_blank()
ggplot(df,aes(x=x,y=y))+geom_blank()
ggplot(df,aes(x=x,y=y))+geom_blank()+theme_minimal()
quit()
df <- data.frame(x=c(0,1),y=c(0,1))
ggplot(df,aes(x=x,y=y))+geom_blank()+theme_minimal()
library(ggplot2)
ggplot(df,aes(x=x,y=y))+geom_blank()+theme_minimal()
ggplot(df,aes(x=x,y=y))+geom_blank()+theme_minimal()+theme(axis.title.y = element_blank(),# move away for axis
axis.text.y  = element_blank(),
axis.title.x = element_blank(),# move away for axis
axis.text.x  = element_blank(),
panel.grid.major.x=element_blank(),
panel.grid.major.y=element_blank())
ggplot(df,aes(x=x,y=y))+geom_blank()+geom_text(aes(x=0.5,y=0.5),'Test')
theme_minimal()+theme(axis.title.y = element_blank(),# move away for axis
axis.text.y  = element_blank(),
axis.title.x = element_blank(),# move away for axis
axis.text.x  = element_blank(),
panel.grid.major.x=element_blank(),
panel.grid.major.y=element_blank())
ggplot(df,aes(x=x,y=y))+geom_blank()+geom_text(aes(x=0.5,y=0.5),'Test')+
theme_minimal()+theme(axis.title.y = element_blank(),# move away for axis
axis.text.y  = element_blank(),
axis.title.x = element_blank(),# move away for axis
axis.text.x  = element_blank(),
panel.grid.major.x=element_blank(),
panel.grid.major.y=element_blank())
ggplot(df,aes(x=x,y=y))+geom_blank()+geom_text(aes(x=0.5,y=0.5),'Test')+
df
df <- data.frame(x=c(0.5),y=c(0.5),text='No Data Available')
df
ggplot(df,aes(x=x,y=y,label=text)+geom_text()+
theme_minimal()+theme(axis.title.y = element_blank(),# move away for axis
axis.text.y  = element_blank(),
axis.title.x = element_blank(),# move away for axis
axis.text.x  = element_blank(),
panel.grid.major.x=element_blank(),
panel.grid.major.y=element_blank())
ggplot(df,aes(x=x,y=y,label=text)+geom_text()
ggplot(df,aes(x=x,y=y,label=text))+geom_text()
ggplot(df,aes(x=x,y=y,label=text))+geom_text()+
theme_minimal()+theme(axis.title.y = element_blank(),# move away for axis
axis.text.y  = element_blank(),
axis.title.x = element_blank(),# move away for axis
axis.text.x  = element_blank(),
panel.grid.major.x=element_blank(),
panel.grid.major.y=element_blank())
q()
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
quit()
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
install.packages('forecast')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
library(forecast)
make_temp_pdf <- function(offset,sigma){
pdfvals <- c()
for (i in 0:101){
pdfvals <- append(pdfvals, exp(-(i-offset)**2 / (2 * sigma**2)))
}
return(pdfvals)
}
boundedMarkovChain <- function(offset,maxStepSize,upperBound,lowerBound,pdfvals,n_sec=86400,full_output=FALSE){
bmc <- c()
times <- c()
bmchist <- integer(1000)
val <- offset
set.seed(as.numeric(Sys.time()))
for (i in 0:(n_sec-1)){
# Add next value as dependent on current state
val <- val + (runif(1,-0.5,.5)*maxStepSize*(1.01-pdfvals[round(val)+1]))
# Check bounds
val <- min(c(max(c(val,lowerBound)),upperBound))
bmchist[min(c(floor(val*10.0)+1,999))] <- bmchist[min(c(floor(val*10.0)+1,999))]+1
if (full_output){
bmc <- append(bmc,val)
times <- append(times,i)
} else {
if (mod(i,max(c(round(n_sec/1000),1)))==0){
bmc <- append(bmc,val)
times <- append(times,i)
}
}
}
return(list("times"=times,"bmc"=bmc,"bmchist"=bmchist))
}
justtheerrors <- function(data,ranges){
minrange <- round(ranges[1]-(2*ranges[2]),1)
maxrange <- round(ranges[1]+(2*ranges[2]),1)
df <- data.frame(cbind(data$times,data$bmc,sign(data$bmc-minrange),sign(data$bmc-maxrange)))
colnames(df)<- c('Time','Temp','Type','high')
if (length(which(((df$Type<=0)|(df$high >=0))==TRUE))>0){
df2 <- df[(df$Type<=0)|(df$high >=0),]
df2$Type <- "LOW"
df2$Type[df2$high>0] <- "HIGH"
return(cbind(round(df2$Time/60,2),round(df2$Temp,2),df2$Type))
} else {
df <- data.frame(cbind(NaN,NaN,'N/A'))
colnames(df) <- c('Time','Temp','Type')
return(cbind(df$Time,df$Temp,df$Type))
}
}
stepSize=2.0 #log10(input$n_sec)
sigma=stepSize*7.5
offset = 25
bmc <- boundedMarkovChain(offset,
maxStepSize=5.5,
upperBound=100.0,
lowerBound=0.0,
make_temp_pdf(offset,sigma),
n_sec=7200, #1 hours
full_output=TRUE
)
bmc$times
myts <- ts(bmc$bmc)
myts
head(myts)
head(bmc$bmc)
head(bmc$times)
myts <- ts(bmc$bmc,start=bmc$times[1],end=bmc$times[nrow(bmc$times)])
myts <- ts(bmc$bmc,start=bmc$times[1],end=bmc$times[-1])
bmc$times[-1]
bmc$times[nrow(bmc$times)]
bmc$times[length(bmc$times)]
myts <- ts(bmc$bmc,start=bmc$times[1],end=bmc$times[length(bmc$times)])
myts
plot(myts)
model <- arima(myts, order=c(p, d, q))
p
model <- arima(myts)
accuracy(model)
plot(forecast(model,300))
accuracy(model,order=c(p))
accuracy(model,order=p
)
accuracy(model,order=3)
model <- arima(myts,order=p)
model <- auto.arima(myts)
plot(forecast(model,300))
forecast(model,30)
forecast(model,300)
plot(forecast(model,1800))
model <- arima(myts,order=c(10,15,10))
model <- arima(myts,order=c(10,15,1))
model <- arima(myts,order=c(1,3,1))
plot(forecast(model,1800))
model <- arima(myts,order=c(0,3,1))
plot(forecast(model,1800))
model <- arima(myts,order=c(0,3,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(0,1,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(0,0.5,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(0,0.75,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(0,1.3,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(0.25,1.5,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,1.55,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,1.55,1))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,2,1))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,1,1))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,4,1))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,3,1))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,2,1))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,2,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,2,1))
model <- arima(myts,order=c(1,0,1))
model <- arima(myts,order=c(1,2,1))
model <- arima(myts,order=c(1,0,1))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,0,2))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,1,2))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,1,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(0,1,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,1,0))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,1,2))
plot(forecast(model,1800))
model <- arima(myts,order=c(1,2,2))
plot(forecast(model,1800))
fit <- stl(myts, s.window="period")
plot(fit)
fit <- stl(myts)
fit <- stl(myts,s.window=7)
fit <- stl(myts,s.window=91)
fit <- stl(myts,t.window=9)
fit <- stl(myts)
forecast(model,20)
model <- arima(myts,order=c(2,2,2))
plot(forecast(model,1800))
model <- arima(myts,order=c(2,1,2))
plot(forecast(model,1800))
model <- arima(myts,order=c(2,1,1))
plot(forecast(model,1800))
model <- arima(myts,order=c(2,1,0))
plot(forecast(model,1800))
plot(forecast(model,300))
model <- arima(myts,order=c(2,1,3))
plot(forecast(model,300))
model <- arima(myts,order=c(2,0,3))
plot(forecast(model,300))
model <- arima(myts,order=c(0,0,3))
plot(forecast(model,300))
model <- arima(myts,order=c(1,0,3))
plot(forecast(model,300))
model <- arima(myts,order=c(3,0,3))
plot(forecast(model,300))
model <- arima(myts,order=c(3,0,4))
plot(forecast(model,300))
model <- arima(myts,order=c(3,1,4))
plot(forecast(model,300))
summary(model)
model <- arima(myts,order=c(3,1,1))
summary(model)
model <- arima(myts,order=c(3,1,4))
summary(model)
model <- arima(myts,order=c(1,1,1))
summary(model)
model <- auto.arima(myts,approximation=FALSE,trace=FALSE)
summary(model)
plot(forecast(model,300))
plot(diff(myts))
acf(diff(myts))
pacf(diff(myts))
acf(diff(myts))
model <- auto.arima(myts)
plot(forecast(model,10))
plot(forecast(model,1800))
plot(forecast(model,900))
plot(forecast(model,300))
plot(forecast(model,360))
plot(forecast(model,h=360))
quit()
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
q()
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
quit()
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
q()
shiny::runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
library(magrittr)
library(saves)
library(shiny)
library(dplyr)
library(curl) # make the jsonlite suggested dependency explicit
library(ggplot2)
library(xts)
library(plotly)
library(forecast)
# Create function for estimating likelihood of greater increase/decrease
make_temp_pdf <- function(offset,sigma){
pdfvals <- c()
for (i in 0:101){
pdfvals <- append(pdfvals, exp(-(i-offset)**2 / (2 * sigma**2)))
}
return(pdfvals)
}
# Simulate temperatures for input to test algorithm
boundedMarkovChain <- function(offset,maxStepSize,upperBound,lowerBound,pdfvals,n_sec=86400,full_output=FALSE){
bmc <- c()
times <- c()
bmchist <- integer(1000)
val <- offset
set.seed(as.numeric(Sys.time()))
for (i in 0:(n_sec-1)){
# Add next value as dependent on current state
val <- val + (runif(1,-0.5,.5)*maxStepSize*(1.01-pdfvals[round(val)+1]))
# Check bounds
val <- min(c(max(c(val,lowerBound)),upperBound))
bmchist[min(c(floor(val*10.0)+1,999))] <- bmchist[min(c(floor(val*10.0)+1,999))]+1
if (full_output){
bmc <- append(bmc,val)
times <- append(times,i)
} else {
if (mod(i,max(c(round(n_sec/1000),1)))==0){
bmc <- append(bmc,val)
times <- append(times,i)
}
}
}
return(list("times"=times,"bmc"=bmc,"bmchist"=bmchist))
}
justtheerrors <- function(data,ranges){
minrange <- round(ranges[1]-(2*ranges[2]),1)
maxrange <- round(ranges[1]+(2*ranges[2]),1)
df <- data.frame(cbind(data$times,data$bmc,sign(data$bmc-minrange),sign(data$bmc-maxrange)))
colnames(df)<- c('Time','Temp','Type','high')
if (length(which(((df$Type<=0)|(df$high >=0))==TRUE))>0){
df2 <- df[(df$Type<=0)|(df$high >=0),]
df2$Type <- "LOW"
df2$Type[df2$high>0] <- "HIGH"
return(cbind(round(df2$Time/60,2),round(df2$Temp,2),df2$Type))
} else {
df <- data.frame(cbind(NaN,NaN,'N/A'))
colnames(df) <- c('Time','Temp','Type')
return(cbind(df$Time,df$Temp,df$Type))
}
}
stepSize=2.0 #log10(input$n_sec)
sigma=stepSize*7.5
offset = 25
bmc <- boundedMarkovChain(offset,
maxStepSize=5.5,
upperBound=100.0,
lowerBound=0.0,
pdfvals=make_temp_pdf(offset,sigma),
n_sec=86400)
bmc
shape(bmc)
size(bmc)
bmc.shape()
bmc.shape
bmc.size()
sigma
rtdata <- boundedMarkovChain(offset,
maxStepSize=5.5,
upperBound=100.0,
lowerBound=0.0,
make_temp_pdf(offset,sigma),
n_sec=7200, #1 hours
full_output=TRUE
)
ts <- ts(rtdata$bmc,start=0,end=7200)
model <- lm(rtdata$bmc ~ poly(rtdata$times,3))
fcast <- forecast(model,300)
model
rtdata$times
newtime <- data.frame(time=max(rtdata$times)+seq(60,86400,300))
newtime
rtdata$times[1,]
rtdata$times[1]
rtdata$times[-1]
seq(0,10,2)
seq(rtdata$times[length(rtdata$times)],rtdata$times[length(rtdata$times)]+300,1)
seq(rtdata$times[length(rtdata$times)]+1,rtdata$times[length(rtdata$times)]+301,1)
newtimes <- seq(rtdata$times[length(rtdata$times)]+1,rtdata$times[length(rtdata$times)]+301,1)
newtimes <- data.frame(seq(rtdata$times[length(rtdata$times)]+1,rtdata$times[length(rtdata$times)]+301,1))
newtime <- newtimes
predictions <- predict(model,newtime,interval="prediction")
fitted(model)
model <- lm(rtdata$bmc~ rtdata$times)
model
model <- lm(rtdata$bmc ~ poly(rtdata$times,3))
model
rtdata$regression <- fitted(model)
predictions <- predict(model,newtime,interval="prediction")
predictions
predictions <- data.frame(cbind(newtime,predictions))
length(predictions)
length(newtime)
newtime
newtimes
max(rtdata$times)
newtime <- data.frame(time=max(rtdata$times)+seq(1,300,1))
predictions <- predict()
predictions <- predict(model, newtime, interval="prediction")
newtime
model
time <- rtdata$times
model <- lm(rtdata$bmc ~ poly(time,3))
rtdata$regression <- fitted(model)
newtime <- data.frame(time=max(time)+seq(1,300,1))
predictions <- predict(model, newtime, interval="prediction")
predictions <- data.frame(cbind(newtime,predictions))
predictions
fcast(model,300)
forecast(model,300)
model
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
runApp('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
cd Documents/Work/Projects/T-Systems/IoT/sensorsim-app
chdir('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
setwd('Documents/Work/Projects/T-Systems/IoT/sensorsim-app')
pwd
getwd
getwd()
runApp()
names(predictions)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
rtdata
predictions
newtime
model
forecast(model)
forecast(model,newtime)
forecast(model,300)
model
model(time)
model()\
model()
model
ts(rtdata()$bmc,start=min(time),end=max(time))
tt<-ts(rtdata$bmc,start=min(time),end=max(time))
tt
auto.arima(y=tt)
abc <- auto.arima(tt)
plot(forecast(abc,300))
plot(forecast(abc,30))
plot(forecast(abc,50))
plot(forecast(abc,100))
plot(forecast(abc,300))
plot(forecast(abc,60))
plot(forecast(abc,600))
auto.arima(tt)
plot(forecast(abc,60))
plot(forecast(abc,200))
plot(forecast(abc,150))
plot(forecast(abc,100))
plot(forecast(abc,100))
plot(forecast(abc,150))
plot(forecast(abc,150),ylim=c(mean(rtdata$bmc)-sd(rtdata$bmc),mean(rtdata$bmc)+sd(rtdata$bmc)))
plot(forecast(abc,150),ylim=c(mean(rtdata$bmc)-sd(rtdata$bmc)*2,mean(rtdata$bmc)+2*sd(rtdata$bmc)))
plot(forecast(abc,150),ylim=c(mean(rtdata$bmc)-sd(rtdata$bmc)*4,mean(rtdata$bmc)+4*sd(rtdata$bmc)))
plot(forecast(abc,150),ylim=c(mean(rtdata$bmc)-sd(rtdata$bmc),mean(rtdata$bmc)+sd(rtdata$bmc)))
plot(forecast(abc,150),ylim=c(mean(rtdata$bmc)-sd(rtdata$bmc)*4,mean(rtdata$bmc)+4*sd(rtdata$bmc)))
plot(forecast(abc,150),ylim=c(mean(rtdata$bmc)-(sd(rtdata$bmc)*5),mean(rtdata$bmc)+(4*sd(rtdata$bmc))))
plot(forecast(abc,150),ylim=c(mean(rtdata$bmc)-(sd(rtdata$bmc)*5),mean(rtdata$bmc)+(5*sd(rtdata$bmc))))
plot(forecast(abc,150),ylim=c(mean(rtdata$bmc)-(sd(rtdata$bmc)*5),mean(rtdata$bmc)+(4*sd(rtdata$bmc))))
6
plot(forecast(abc,150),ylim=c(mean(rtdata$bmc)-(sd(rtdata$bmc)*6),mean(rtdata$bmc)+(4*sd(rtdata$bmc))))
q()
